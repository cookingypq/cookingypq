# CookingYPQ 产品设计文档

## 项目概述

### 项目目标
复刻 [Patterns in the Void](https://patternsinthevoid.net) 网站的视觉效果和交互体验，使用现代技术栈（TypeScript + Tailwind CSS + Bun）重新构建。

### 核心特性
1. **复古8-bit风格设计** - 参考patternsinthevoid的视觉风格
2. **可拖拽的伴偶效果** - 主页具有可鼠标拖拽的交互元素
3. **现代技术栈** - TypeScript + Tailwind CSS + Bun
4. **组件化设计** - 集成8bitcn.com的组件库 
                4.1 8bitcn组件-Accordion: 
                Installation: 
                bunx --bun shadcn@latest add https://8bitcn.com/r/8bit-accordion.json

                Usage: 
                import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/8bit/accordion"

                <Accordion type="single" collapsible>
                    <AccordionItem value="item-1">
                      <AccordionTrigger>Is it accessible?</AccordionTrigger>
                      <AccordionContent>
                        Yes. It adheres to the WAI-ARIA design pattern.
                      </AccordionContent>
                    </AccordionItem>
                  </Accordion>

                4.2 8bit组件-Alert:
                Installation:
                bunx --bun shadcn@latest add https://8bitcn.com/r/8bit-alert.json

                Usage:
                import { Alert, AlertDescription, AlertTitle } from "@/components/ui/8bit/alert"

                <Alert>
                  <AlertTitle>Heads up!</AlertTitle>
                  <AlertDescription>
                    You can add components and dependencies to your app using the cli.
                  </AlertDescription>
                </Alert>

                4.3 8bit组件-Alert Dialog:
                Installation:
                bunx --bun shadcn@latest add https://8bitcn.com/r/8bit-alert-dialog.json

                Usage:
                import {
                  AlertDialog,
                  AlertDialogAction,
                  AlertDialogCancel,
                  AlertDialogContent,
                  AlertDialogDescription,
                  AlertDialogFooter,
                  AlertDialogHeader,
                  AlertDialogTitle,
                  AlertDialogTrigger,
                } from "@/components/ui/8bit/alert-dialog"

                <AlertDialog>
                    <AlertDialogTrigger><Button variant="outline">Open</Button></AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This action cannot be undone. This will permanently delete your account
                          and remove your data from our servers.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction>Continue</AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
, 


5. **文本动画效果** - 使用reactbits.dev的Fuzzy Text特效

                    Usage:
                    import FuzzyText from './FuzzyText';

                      <FuzzyText 
                        baseIntensity={0.2} 
                        hoverIntensity={hoverIntensity} 
                        enableHover={enableHover}
                      >
                        404
                      </FuzzyText>

                    Code:
                    import React, { useEffect, useRef } from "react";

interface FuzzyTextProps {
  children: React.ReactNode;
  fontSize?: number | string;
  fontWeight?: string | number;
  fontFamily?: string;
  color?: string;
  enableHover?: boolean;
  baseIntensity?: number;
  hoverIntensity?: number;
}

const FuzzyText: React.FC<FuzzyTextProps> = ({
  children,
  fontSize = "clamp(2rem, 8vw, 8rem)",
  fontWeight = 900,
  fontFamily = "inherit",
  color = "#fff",
  enableHover = true,
  baseIntensity = 0.18,
  hoverIntensity = 0.5,
}) => {
  const canvasRef = useRef<HTMLCanvasElement & { cleanupFuzzyText?: () => void}>(null);

  useEffect(() => {
    let animationFrameId: number;
    let isCancelled = false;
    const canvas = canvasRef.current;
    if (!canvas) return;

    const init = async () => {
      if (document.fonts?.ready) {
        await document.fonts.ready;
      }
      if (isCancelled) return;

      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const computedFontFamily =
        fontFamily === "inherit"
          ? window.getComputedStyle(canvas).fontFamily || "sans-serif"
          : fontFamily;

      const fontSizeStr =
        typeof fontSize === "number" ? `${fontSize}px` : fontSize;
      let numericFontSize: number;
      if (typeof fontSize === "number") {
        numericFontSize = fontSize;
      } else {
        const temp = document.createElement("span");
        temp.style.fontSize = fontSize;
        document.body.appendChild(temp);
        const computedSize = window.getComputedStyle(temp).fontSize;
        numericFontSize = parseFloat(computedSize);
        document.body.removeChild(temp);
      }

      const text = React.Children.toArray(children).join("");

      const offscreen = document.createElement("canvas");
      const offCtx = offscreen.getContext("2d");
      if (!offCtx) return;

      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;
      offCtx.textBaseline = "alphabetic";
      const metrics = offCtx.measureText(text);

      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;
      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;
      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;
      const actualDescent =
        metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;

      const textBoundingWidth = Math.ceil(actualLeft + actualRight);
      const tightHeight = Math.ceil(actualAscent + actualDescent);

      const extraWidthBuffer = 10;
      const offscreenWidth = textBoundingWidth + extraWidthBuffer;

      offscreen.width = offscreenWidth;
      offscreen.height = tightHeight;

      const xOffset = extraWidthBuffer / 2;
      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;
      offCtx.textBaseline = "alphabetic";
      offCtx.fillStyle = color;
      offCtx.fillText(text, xOffset - actualLeft, actualAscent);

      const horizontalMargin = 50;
      const verticalMargin = 0;
      canvas.width = offscreenWidth + horizontalMargin * 2;
      canvas.height = tightHeight + verticalMargin * 2;
      ctx.translate(horizontalMargin, verticalMargin);

      const interactiveLeft = horizontalMargin + xOffset;
      const interactiveTop = verticalMargin;
      const interactiveRight = interactiveLeft + textBoundingWidth;
      const interactiveBottom = interactiveTop + tightHeight;

      let isHovering = false;
      const fuzzRange = 30;

      const run = () => {
        if (isCancelled) return;
        ctx.clearRect(
          -fuzzRange,
          -fuzzRange,
          offscreenWidth + 2 * fuzzRange,
          tightHeight + 2 * fuzzRange
        );
        const intensity = isHovering ? hoverIntensity : baseIntensity;
        for (let j = 0; j < tightHeight; j++) {
          const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);
          ctx.drawImage(
            offscreen,
            0,
            j,
            offscreenWidth,
            1,
            dx,
            j,
            offscreenWidth,
            1
          );
        }
        animationFrameId = window.requestAnimationFrame(run);
      };

      run();

      const isInsideTextArea = (x: number, y: number) =>
        x >= interactiveLeft &&
        x <= interactiveRight &&
        y >= interactiveTop &&
        y <= interactiveBottom;

      const handleMouseMove = (e: MouseEvent) => {
        if (!enableHover) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        isHovering = isInsideTextArea(x, y);
      };

      const handleMouseLeave = () => {
        isHovering = false;
      };

      const handleTouchMove = (e: TouchEvent) => {
        if (!enableHover) return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        isHovering = isInsideTextArea(x, y);
      };

      const handleTouchEnd = () => {
        isHovering = false;
      };

      if (enableHover) {
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseleave", handleMouseLeave);
        canvas.addEventListener("touchmove", handleTouchMove, {
          passive: false,
        });
        canvas.addEventListener("touchend", handleTouchEnd);
      }

      const cleanup = () => {
        window.cancelAnimationFrame(animationFrameId);
        if (enableHover) {
          canvas.removeEventListener("mousemove", handleMouseMove);
          canvas.removeEventListener("mouseleave", handleMouseLeave);
          canvas.removeEventListener("touchmove", handleTouchMove);
          canvas.removeEventListener("touchend", handleTouchEnd);
        }
      };

      canvas.cleanupFuzzyText = cleanup;
    };

    init();

    return () => {
      isCancelled = true;
      window.cancelAnimationFrame(animationFrameId);
      if (canvas && canvas.cleanupFuzzyText) {
        canvas.cleanupFuzzyText();
      }
    };
  }, [
    children,
    fontSize,
    fontWeight,
    fontFamily,
    color,
    enableHover,
    baseIntensity,
    hoverIntensity,
  ]);

  return <canvas ref={canvasRef} />;
};

export default FuzzyText;
 
              


## 设计规范

### 视觉风格
- **主色调**: 深色背景 (#0a0a0a) + 高对比度文字
- **字体**: 等宽字体，8-bit像素风格
- **布局**: 极简主义，注重内容可读性
- **动画**: 复古像素动画效果

### 页面结构

#### 主页 (Homepage)
```
┌─────────────────────────────────────┐
│ Header (Logo + Navigation)         │
├─────────────────────────────────────┤
│                                     │
│  Hero Section                       │
│  - 可拖拽伴偶 (Draggable Companion) │
│  - 动态文本效果                     │
│  - 8-bit风格装饰元素               │
│                                     │
├─────────────────────────────────────┤
│ Content Sections                    │
│ - 文章列表                         │
│ - 分类导航                         │
│ - 社交媒体链接                     │
├─────────────────────────────────────┤
│ Footer                             │
└─────────────────────────────────────┘
```

#### 文章页面 (Article Page)
```
┌─────────────────────────────────────┐
│ Header                             │
├─────────────────────────────────────┤
│ Article Content                     │
│ - 标题 (带动画效果)                 │
│ - 元数据 (日期、分类、标签)         │
│ - 正文内容                         │
│ - 代码高亮                         │
│ - 导航 (上一篇/下一篇)              │
├─────────────────────────────────────┤
│ Footer                             │
└─────────────────────────────────────┘
```

### 交互设计

#### 伴偶拖拽系统
- **拖拽范围**: 整个视窗
- **物理效果**: 弹性边界，重力效果
- **交互反馈**: 鼠标悬停高亮，拖拽时缩放
- **持久化**: 位置状态保存到localStorage

#### 文本动画效果
- **Split Text**: 字符逐个显示动画
- **Typewriter**: 打字机效果
- **Glitch**: 故障效果
- **Pixel Art**: 像素化文字效果

#### 8-bit组件集成
- **按钮**: 复古游戏风格按钮
- **卡片**: 像素边框卡片
- **模态框**: 游戏菜单风格
- **进度条**: 像素风格进度指示器

## 技术架构

### 前端技术栈
- **框架**: React 18 + TypeScript
- **样式**: Tailwind CSS + 自定义8-bit样式
- **构建工具**: Bun
- **状态管理**: Zustand
- **动画**: Framer Motion + GSAP
- **路由**: React Router

### 组件库
- **8bitcn组件**: 复古UI组件
- **自定义组件**: 拖拽系统、文本动画
- **工具组件**: 布局、导航、SEO

### 项目结构
```
cookingypq/
├── src/
│   ├── components/
│   │   ├── ui/           # 8bitcn组件
│   │   ├── layout/       # 布局组件
│   │   ├── draggable/    # 拖拽系统
│   │   └── animations/   # 动画组件
│   ├── pages/
│   │   ├── Home.tsx
│   │   ├── Article.tsx
│   │   └── About.tsx
│   ├── hooks/
│   │   ├── useDraggable.ts
│   │   └── useTextAnimation.ts
│   ├── utils/
│   │   ├── animations.ts
│   │   └── storage.ts
│   └── styles/
│       ├── globals.css
│       └── 8bit.css
├── public/
│   ├── images/
│   └── fonts/
└── package.json
```

## 功能模块

### 1. 拖拽伴偶系统
- **组件**: `DraggableCompanion`
- **功能**: 
  - 鼠标拖拽移动
  - 边界碰撞检测
  - 位置持久化
  - 动画效果

### 2. 文本动画系统
- **组件**: `SplitText`, `TypewriterText`, `GlitchText`
- **功能**:
  - 字符分割动画
  - 打字机效果
  - 故障效果
  - 像素化效果

### 3. 8-bit UI组件
- **按钮**: `RetroButton`
- **卡片**: `PixelCard`
- **模态框**: `GameModal`
- **进度条**: `PixelProgress`

### 4. 内容管理系统
- **文章渲染**: Markdown支持
- **代码高亮**: Prism.js
- **分类系统**: 标签和分类
- **搜索功能**: 全文搜索

## 性能优化

### 加载优化
- **代码分割**: React.lazy + Suspense
- **图片优化**: WebP格式，懒加载
- **字体优化**: 预加载关键字体

### 交互优化
- **防抖**: 拖拽事件防抖
- **节流**: 动画帧率控制
- **缓存**: 组件状态缓存

## 响应式设计

### 断点设计
- **移动端**: < 768px
- **平板**: 768px - 1024px
- **桌面**: > 1024px

### 适配策略
- **拖拽系统**: 移动端触摸支持
- **动画效果**: 根据设备性能调整
- **布局**: 弹性布局适配

## 开发计划

### 第一阶段 (MVP)
1. 项目初始化
2. 基础布局组件
3. 拖拽伴偶系统
4. 主页实现

### 第二阶段 (功能完善)
1. 文本动画系统
2. 8-bit组件集成
3. 文章页面
4. 响应式优化

### 第三阶段 (优化发布)
1. 性能优化
2. SEO优化
3. 测试和调试
4. 部署上线

## 质量标准

### 代码质量
- **TypeScript**: 严格类型检查
- **ESLint**: 代码规范检查
- **Prettier**: 代码格式化
- **测试覆盖率**: > 80%

### 用户体验
- **加载时间**: < 3秒
- **交互响应**: < 100ms
- **动画帧率**: 60fps
- **可访问性**: WCAG 2.1 AA标准

### 兼容性
- **浏览器**: Chrome, Firefox, Safari, Edge
- **设备**: 桌面、平板、手机
- **网络**: 3G及以上 